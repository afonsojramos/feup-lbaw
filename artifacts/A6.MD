# A6: Indexes, triggers, user functions and population

## 1. Database Workload


This artefact contains the physical schema of the database, the identification and characterisation of the indexes, the support of data integrity rules with triggers and the definition of the database user-defined functions. This artefact also covers the database's workload as well as the whole database creation script, including all SQL required to define all integrity constraints, indexes and triggers.




### 1.1. Tuple Estimation

| Relation reference | Relation Name | Order of magnitude        | Estimated growth  |
| ------------------ | ------------- | ------------------------- | ----------------  |
| R01                | user          | thousands				 | dozens per day    |
| R02                | following     | tens of thousands 	 	 | hundreds per day  |
| R03                | country       | hundreds					 | no growth		 |
| R04                | city	         | thousands				 | hundreds per year |
| R05	             | university    | hundreds					 | no growth         |
| R06	             | faculty	     | thousands				 | units per month   |
| R07	             | post		     | hundreds					 | hundreds per year |
| R08	             | comment	     | thousands				 | dozens per month  |
| R09	             | flag_user     | dozens					 | units per month   |
| R10	             | flag_comment  | dozens					 | units per month   |
| R11	             | flag_post  	 | dozens					 | units per month   |
| R12	             | vote		  	 | tens of thousands		 | hundreds per day  |



### 1.2. Frequent Queries

These are the antecipated most frequent SELECT queries on VECTO.

<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT01</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>User's Profile information</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per hour</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT name, email, username, description, type 
  FROM "user" 
  WHERE "user".id = $userId;

```

</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT02</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Search user by username</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per hour</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT name, email, username, description, type 
  FROM "user" 
  WHERE "user".username = $username;

```

</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT03</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Get a Post's information, as well as owner's name and faculties' names.</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>hundreds per hour</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT p.id, p.title, p.votes, p.content, p.school_year,
p.date, p.removed_date, p.removed_reason, p.date,
u.id AS user_id, u.username AS user_name,
fs.id AS from_faculty_id, fs.name as from_faculty_name,
fd.id AS to_faculty_id, fd.name AS to_faculty_name
  FROM (((post AS p
  INNER JOIN public.user AS u ON p.author_id = u.id)
  INNER JOIN public.faculty AS fs ON p.from_faculty_id = fs.id)
  INNER JOIN public.faculty AS fd ON p.to_faculty_id = fd.id)
  
  WHERE post.id = $post_id;

```

</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT04</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Get a Post's information, as well as owner's name and faculties' names by author_id.</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per hour</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT p.id, p.title, p.votes, p.content, p.school_year,
p.date, p.removed_date, p.removed_reason, p.date,
u.id AS user_id, u.username AS user_name,
fs.id AS from_faculty_id, fs.name as from_faculty_name,
fd.id AS to_faculty_id, fd.name AS to_faculty_name
  FROM (((post AS p
  INNER JOIN public.user AS u ON p.author_id = u.id)
  INNER JOIN public.faculty AS fs ON p.from_faculty_id = fs.id)
  INNER JOIN public.faculty AS fd ON p.to_faculty_id = fd.id)
  
  WHERE post.author_id = $author_id;

```

</td>
	</tr>
</table>



<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT05</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Search for posts</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT p.id, p.title, p.votes, p.content, p.school_year,
p.date, p.removed_date, p.removed_reason, p.date,
u.id AS user_id, u.username AS user_name,
fs.id AS from_faculty_id, fs.name as from_faculty_name,
fd.id AS to_faculty_id, fd.name AS to_faculty_name
  FROM (((post AS p
  INNER JOIN public.user AS u ON p.author_id = u.id)
  INNER JOIN public.faculty AS fs ON p.from_faculty_id = fs.id)
  INNER JOIN public.faculty AS fd ON p.to_faculty_id = fd.id)

WHERE 
(p.search_title || p.search_content) @@ plainto_tsquery('english', $search_query)
ORDER BY ts_rank(
	setweight(u.search_title, 'A') || setweight(u.search_content, 'B'),
	plainto_tsquery('english', $search_query)
) DESC
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT06</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Post's comments with user information</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>hundreds per hour</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT
  c.id AS comment_id, c.content, c.date, u.id AS user_id, u.username
FROM public.comment AS c
INNER JOIN public.user AS u
  ON c.author_id = u.id
WHERE c.post_id = $post_id;
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT07</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Retreive followers of a user</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT
  follower_id, public.user.username
FROM (following
INNER JOIN public.user
  ON follower_id = public.user.id)
WHERE followed_id = $user_id;
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>SELECT08</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Retreive users followed by a user</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
SELECT
  followed_id, public.user.username
FROM (following
INNER JOIN public.user
  ON followed_id = public.user.id)
WHERE follower_id = $user_id;
```
</td>
	</tr>
</table>



### 1.3. Frequent Updates

These are the antecipated most frequent UPDATE, DELETE and INSERT queries on VECTO.


<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE01</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Block User</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per week</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.user SET type = `isBLocked` WHERE id = $user_id;
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE02</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Update Comment</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.comment SET content = $content WHERE id = $comment_id;
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE03</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Edit User Profile</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.user
SET email = $email_id, username = $username,
birthdate = $birthdate, name = $name, description = $description
WHERE id = $user_id;
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE04</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Update Post</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.post
SET title = $title, content = $content, from_faculty_id = $from_faculty_id, 
to_faculty_id = $to_faculty_id, beer_cost = $beer_cost, life_cost = $life_cost, 
native_friendliness = $native_friendliness, work_load = $work_load,
WHERE id = $post_id;
```


</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE05</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Archive Comment Flag</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.flag_comment
SET archived = TRUE
WHERE flagger_id = $flagger_id AND comment_id = $comment_id
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE06</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Archive Post Flag</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.post_comment
SET archived = TRUE
WHERE flagger_id = $flagger_id AND post_id = $post_id
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE07</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Archive User Flag</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.post_comment
SET archived = TRUE
WHERE flagger_id = $flagger_id AND flagged_id = $flagged_id
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>UPDATE08</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Change User password</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
UPDATE public.user SET password = $password WHERE id = $user_id;
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT01</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Insert Comment</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.comment
  (id, content, date, removed_date, removed_reason, post_id, author_id)
  VALUES(NULL, $content, NOW(), NULL, NULL, $postID, $authorID);
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT02</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>User Registration</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.user (email, username, birthdate, name, type)
VALUES ($email, $username, $birthdate, $name, "active");
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT03</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Flag Comment</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.flag_comment
  (flagger_id, comment_id, reason, date, archived)
  VALUES($flagger_id , $comment_id, $reason, NOW(), FALSE);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT04</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Flag Post</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.flag_post
  (flagger_id, post_id, reason, date, archived)
  VALUES($flagger_id , $post_id, $reason, NOW(), FALSE);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT05</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Flag User</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.flag_user
  (flagger_id, flagged_id, reason, date, archived)
  VALUES($flagger_id , $user_id, $reason, NOW(), FALSE);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>INSERT06</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Create Post</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>dozens per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
INSERT INTO public.post
  (id, title, votes, content, school_year, date, removed_reason, removed_date, 
   author_id, from_faculty_id, to_faculty_id, beer_cost, life_cost,
   native_friendliness, work_load)
  VALUES(NULL, $title, 0, $content, $school_year, NOW(), NULL, NULL, $author_id, 
         $from_faculty_id, $to_faculty_id, $beer_cost, $life_cost, 
         $native_friendliness, $work_load);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>DELETE01</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Delete Comment</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
DELETE FROM public.comment 
WHERE id = $id;
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Query reference</th>
		<td>DELETE02</td>
	</tr>
	<tr>
		<th>Query description</th>
		<td>Delete Post</td>
	</tr>
	<tr>
		<th>Query frequency</th>
		<td>units per day</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
			
```sql
DELETE FROM public.post 
WHERE id = $id;
```

</td>
	</tr>
</table>

## 2. Proposed Indices

### 2.1. Performance Indices

<table>
	<tr>
		<th>Index reference</th>
		<td>IDX01</td>
	</tr>
	<tr>
		<th>Related queries</th>
		<td>SELECT02</td>
	</tr>
	<tr>
		<th>Index relation</th>
		<td>user</td>
	</tr>
	<tr>
		<th>Index attribute</th>
		<td>username</td>
	</tr>
	<tr>
		<th>Index type</th>
		<td>hash</td>
	</tr>
	<tr>
		<th>Cardinality</th>
		<td>high</td>
	</tr>
	<tr>
		<th>Clustering</th>
		<td>no</td>
	</tr>
	<tr>
		<th>Justification</th>
		<td>Query SELECT01 should be fast to allow users to be located quickly; doesn't need range query support; cardinality is high because id is the primary key; it's not a good candidate for clustering.
</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE INDEX user_username ON "user" USING hash (username);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Index reference</th>
		<td>IDX02</td>
	</tr>
	<tr>
		<th>Related queries</th>
		<td>SELECT04</td>
	</tr>
	<tr>
		<th>Index relation</th>
		<td>post</td>
	</tr>
	<tr>
		<th>Index attribute</th>
		<td>author_id</td>
	</tr>
	<tr>
		<th>Index type</th>
		<td>btree</td>
	</tr>
	<tr>
		<th>Cardinality</th>
		<td>medium</td>
	</tr>
	<tr>
		<th>Clustering</th>
		<td>no</td>
	</tr>
	<tr>
		<th>Justification</th>
		<td>Query SELECT02 must be fast as it'll power basic operations of the app, and will be executed many times; doesn't need range query support; cardinality is medium because a user can be author of several posts; it's not a good candidate for clustering.
</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE INDEX post_author ON "post" USING btree (author_id);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Index reference</th>
		<td>IDX03</td>
	</tr>
	<tr>
		<th>Related queries</th>
		<td>SELECT06</td>
	</tr>
	<tr>
		<th>Index relation</th>
		<td>comment</td>
	</tr>
	<tr>
		<th>Index attribute</th>
		<td>post_id</td>
	</tr>
	<tr>
		<th>Index type</th>
		<td>btree</td>
	</tr>
	<tr>
		<th>Cardinality</th>
		<td>medium</td>
	</tr>
	<tr>
		<th>Clustering</th>
		<td>no</td>
	</tr>
	<tr>
		<th>Justification</th>
		<td>Query SELECT06 must be fast as it'll power basic operations of the app, and will be executed many times; doesn't need range query support; cardinality is medium because a post can have several associated comments; it's not a good candidate for clustering.
</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE INDEX comment_post_id ON "comment" USING btree (post_id);
```
</td>
	</tr>
</table>

### 2.2. Full-text Search Indices 

Full-text Search Indices are used to speed up text searches.

<table>
	<tr>
		<th>Index reference</th>
		<td>IDX05</td>
	</tr>
	<tr>
		<th>Related queries</th>
		<td>SELECT05</td>
	</tr>
	<tr>
		<th>Index relation</th>
		<td>post</td>
	</tr>
	<tr>
		<th>Index attribute</th>
		<td>search_content</td>
	</tr>
	<tr>
		<th>Index type</th>
		<td>GIN</td>
	</tr>
	<tr>
		<th>Cardinality</th>
		<td>medium</td>
	</tr>
	<tr>
		<th>Clustering</th>
		<td>no</td>
	</tr>
	<tr>
		<th>Justification</th>
		<td>The search is a crucial part of the platform's operation and results need to be fast and useful, so the speed is paramount, that is why GIN was chosen over GIST. As a matter of fact, since the content of a post is not expected to change very often after their creation, GIN's drawback on slow indexing is not a concerning aspect.
</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE INDEX search_content_idx ON post USING GIN (search_content);
```
</td>
	</tr>
</table>

<table>
	<tr>
		<th>Index reference</th>
		<td>IDX05</td>
	</tr>
	<tr>
		<th>Related queries</th>
		<td>SELECT05</td>
	</tr>
	<tr>
		<th>Index relation</th>
		<td>post</td>
	</tr>
	<tr>
		<th>Index attribute</th>
		<td>search_title</td>
	</tr>
	<tr>
		<th>Index type</th>
		<td>GIN</td>
	</tr>
	<tr>
		<th>Cardinality</th>
		<td>medium</td>
	</tr>
	<tr>
		<th>Clustering</th>
		<td>no</td>
	</tr>
	<tr>
		<th>Justification</th>
		<td>The search is a crucial part of the platform's operation and results need to be fast and useful, so the speed is paramount, that is why GIN was chosen over GIST. As a matter of fact, since the title of a post is not expected to change very often after their creation, GIN's drawback on slow indexing is not a concerning aspect.
</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE INDEX search_title_idx ON post USING GIN (search_title);
```
</td>
	</tr>
</table>


## 3. Triggers

The following triggers are used to ensure business rules are respected, whenever SQL Constraints are not enough.

<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER01</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>The auxiliary ts_vectors (search_title and search_content) must be updated every time a post is added or updated. This <code>ts_vector()</code> function is only invoked on update if changes have been made to the corresponding fields.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION post_search_update() RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.search_title = to_tsvector('english' , NEW.title);
    NEW.search_content = to_tsvector('english' , NEW.content);
  END IF;
  IF TG_OP = 'UPDATE' THEN
      IF NEW.title <> OLD.title THEN
        NEW.search_title = to_tsvector('english', NEW.title);
      END IF;
      IF NEW.content <> OLD.content THEN
        NEW.search_content = to_tsvector('english', NEW.content);
      END IF;
  END IF;
  RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER post_search_update
  BEFORE INSERT OR UPDATE ON post
  FOR EACH ROW
    EXECUTE PROCEDURE post_search_update(); 
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER02</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>A precondition of the fairness of the website is that users cannot cast votes on their own posts, this problem is tackled via this trigger.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION vote_prevent_own_user() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT id FROM post WHERE NEW.post_id = id 
               AND NEW.user_id = author_id) THEN
      RAISE EXCEPTION 'A user cannot vote on own post.';
    END IF;
    RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER vote_prevent_own_user
  BEFORE INSERT OR UPDATE ON vote
  FOR EACH ROW
    EXECUTE PROCEDURE vote_prevent_own_user(); 
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER03</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>As an additional business rule, users are not allowed to flag their own posts.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION vote_prevent_own_user() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT id FROM post WHERE NEW.post_id = id 
               AND NEW.user_id = author_id) THEN
      RAISE EXCEPTION 'A user cannot vote on own post.';
    END IF;
    RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER vote_prevent_own_user
  BEFORE INSERT OR UPDATE ON vote
  FOR EACH ROW
    EXECUTE PROCEDURE vote_prevent_own_user(); 
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER04</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>As an additional business rule, users are not allowed to flag their own comments.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION user_prevent_self_flag_comment() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT id FROM comment WHERE NEW.comment_id = id 
               AND NEW.flagger_id = author_id) THEN
      RAISE EXCEPTION 'A user cannot flag own post.';
    END IF;
    RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER user_prevent_self_flag_comment
    BEFORE INSERT OR UPDATE ON flag_comment
    FOR EACH ROW
        EXECUTE PROCEDURE user_prevent_self_flag_comment(); 
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER05</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>A user can only perform two mobilities per year, at maximum, which corresponds to one per semester. This is BR02 enhanced to better fit the client's needs.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION max_two_mobilities_per_year() RETURNS TRIGGER AS $$
DECLARE
    count_mobilities numeric;
BEGIN
    SELECT COUNT(id) INTO count_mobilities FROM post WHERE 
        NEW.author_id = author_id AND NEW.school_year = school_year;
    IF count_mobilities = 2 THEN
      RAISE EXCEPTION 'A user cannot participate in more than'+
	  'two mobilities per year, one per semester.';
    END IF;
    RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER max_two_mobilities_per_year
    BEFORE INSERT OR UPDATE ON post
    FOR EACH ROW
        EXECUTE PROCEDURE max_two_mobilities_per_year();
```
</td>
	</tr>
</table>


<table>
	<tr>
		<th>Trigger reference</th>
		<td>TRIGGER06</td>
	</tr>
	<tr>
		<th>Trigger description</th>
		<td>Calculation of the number of votes in a post, whenever a vote is cast or deleted.</td>
	</tr>
	<tr>
		<th colspan=2>SQL Code</th>
	<tr>
		<td colspan=2>
            
```sql
CREATE FUNCTION update_vote() RETURNS TRIGGER AS $$
DECLARE
    count_votes numeric;
BEGIN
    UPDATE post SET votes = (SELECT
				COUNT(CASE 
				  WHEN post_id=NEW.post_id THEN 1 END) 
				AS c FROM vote)
    WHERE id=NEW.post_id;
    RETURN NEW;
END
$$ LANGUAGE 'plpgsql';

CREATE TRIGGER update_vote
  AFTER INSERT OR UPDATE ON vote
  FOR EACH ROW
    EXECUTE PROCEDURE update_vote(); 
```
</td>
	</tr>
</table>


## 4. Complete SQL Code

View Annex 1. Also available on [Github](https://github.com/msramalho/lbaw1721/blob/master/artifacts/A6_full_database.sql).

## Revision history
 
1. Initial submission on 04/04/2018

#### GROUP1721, 28/03/2018

>Afonso Ramos - up201506239@fe.up.pt
Daniel Silva - up201503212@fe.up.pt
Miguel Ramalho - up201403027@fe.up.pt
Vitor Minhoto - up201303086@fe.up.pt

## Annex 1
